# Спринт 3

### Грязнов М

### Задание 1

## Задание 1. Анализ и планирование

### 1. Изучите функциональность монолитного приложения

#### Функции

1. Управление отоплением
2. Мониторинг температуры
Реализованы в одном контроллере
Нет авторизации/защиты
Одна БД с 2мя таблицами
Нет ограничений на количество подключений
Сервисы stateless - возможно горизонтальное масштабирование

### 2. Проанализируйте архитектуру монолитного приложения

Язык программирования: Java
База данных: PostgreSQL
Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
Взаимодействие: Синхронное, запросы обрабатываются последовательно.
Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
Развёртывание: Требует остановки всего приложения.

### 3. Определите домены и границы контекстов

Исходя из текущего решения
Домены:

1. Взаимодействия с датчиками(сенсоры)/устройствами(системы) или просто Устройства
Входит как передача команд, так и получение данных с Устройств
2. Управление устройствами или просто Управление
Входит регистрация устройств, удаление устройств, текущее стостояние
Для целевого сценария доемнов больше
3. Установка/Ослуживание устройств или просто Обслуживание
Физическая установка , настрйока, обслуживание/ремонт, снятие устройств

### 4. Проведите анализ архитектуры монолитного приложения

#### Плюсы

1. Простота реализации - все функции в одном файле

#### Возможные проблемы

1. Надежность: Проблемы с сервисом приводят к сбою всей системы
2. Отказоустойчивость: Зависимость от одной СУБД прои нагрузке могут дать замедление/отказ всей системы
3. Простои в обслуживании: происходят с остановкой сервисов (лечится в данном случае просто - балансир + второй инстанс, с БД сложнее, но тоже реализуемо)
4. Безопасность: нет авторизации/аутентификации, работа ведется по ID датчика

### 5.Визуализируйте контекст системы

.docs\SmartHome ASIS Context.puml

## Задание 2. Проектирование микросервисной архитектуры

### ! Дисклеймер 1
Комментарии к решению:
Ни где не сказано что такое Стандартный протокол. 
От этого зависит вызывающая сторона, реализация протоколов свзяи.
Варианты:
1. Постоянный пинг от устройства к Серверу на предмет получения новых инструкций. Обычный http rest. 
   Плюсы: простота реализации. Минусы: большинство пустых вызывов или задержки реакции устройств.
2. WebSocket. При включении устройстава происходит соединение с Системой и ожидание команд.
   Плюсы: нет лишней нагрузки на сеть. Минусы: ограничение количества подключений, придется продумывать соответсвующую инфраструктуру.
! Возможно webSocket решает проблем - не достаточно зананий.

1. Постоянное TCP соединение почти аналогично WebSocket
   Плюсы: понижение нагрузки на сеть. Минусы: ограничение количества подключений, нет простой защиты (аутентификация/авторизация).

Выбран вариант 1 для реализации: когда устройство с какой-то периодичностью опрашивает Систему.
Это даст: 
   1. быстрый старт за счет простоты реализации
   2. поддержку большой номенклатуры устройств (публичное api)
   3. упрощенную инфраструктуру на старте
   4. возможность быстро увеличить ресурсы за счет обланых решений
Риски:
   1. нагрузка может рости не предсказуемо/усиленными темпами относительно других решений
   2. задержки при управлении устройствами, получении телеметрии 
   3. дополнительные мощности по обработке сообщений от устройств

### ! Дисклеймер 2
Аутентификация устройства 
В вопрос не углубляюсь - предположим, что при первом подключении выдается некий токен, запоминаются характеристики устройства
Вопрос не раскрывается и требует отдельной проработки

### ! Дисклеймер 3
Вопрос действий пратнера не рассматривается

### ! Дисклеймер 4
Вопрос маркетинга не рассматривается


### 1. Декомпозируйте приложение на микросервисы
Субдомены будут представлять из себя Бизнес-сервисы, которые обслуживаются конкретной командой. 
могут состоять из одного или нескольких микросервисов.

Домен - управление устройствами
СубДомены:
1. Канал взаимодействия с Устройствами 
   Рамки: 
    1. Протокол подключения/управления/Взаимодействия с устройствами
    2. Установка соединения с устройством
    3. Получение показаний  (получение сообщений)
    4. Передача конфигурации (отправка сообщений)
    5. Аутентификация устройства
    6. Текущее состояние связи с устройством
! Важно: обеспечить прием и передачу собщений устройствам без задержек

2. Справочник Устройств
  Рамки:
    1. Карточка устройства
    2. Типы устройств
    3. Возможные настройки
    4. Возможные команды
    5. Периодичность взаимодействия
    6. Регистрация новых типов устройств, изменение действующих
  ! Важно: сразу предсмотреть версионность для поддержки разных версий прошивки устройств

3. Зоопарк устройств - управление действющими устройствами
   Рамки:
    1. Обработка сообщений от устройств
    2. Отправка команд/конфигураций стуройствам
    3. Регистрация устройства клиента
    4. Текущие показатели устройства/телеметрии
    5. Конфигурация устрояства
    6. Команды управления устройством
    7. Скрипты/Сценарии управления устройством/Шедуллер

4. Пользователи
    Рамки:
    1. Регистрация
    2. Авторизация/Аутентификация
    3. Права пользователя
    4. Выдача JWT/Проверка JWT
    5. Профиль пользователя

5. Хранилище (Озеро данных/Аудит/Логирование)
  Рамки:
   2.1. История по устройствам (история сообщений, ошибки, состояния)
   2.2. История по клиентам (действия, авторизации, аутентификации)
   2.3. Витрины отчетности


### 2. Определите взаимодействия между

### 3. Визуализируйте архитектуры

#### C4 — Уровень Контекста (Context) 
#### C4 — Уровень контейнеров (Containers)
#### C4 — Уровень компонентов (Components)
#### C4 — Уровень кода (Code).


# Базовая настройка

## Запуск minikube

[Инструкция по установке](https://minikube.sigs.k8s.io/docs/start/)

```bash
minikube start
```

## Добавление токена авторизации GitHub

[Получение токена](https://github.com/settings/tokens/new)

```bash
kubectl create secret docker-registry ghcr --docker-server=https://ghcr.io --docker-username=<github_username> --docker-password=<github_token> -n default
```

## Установка API GW kusk

[Install Kusk CLI](https://docs.kusk.io/getting-started/install-kusk-cli)

```bash
kusk cluster install
```

## Смена адреса образа в helm chart

После того как вы сделали форк репозитория и у вас в репозитории отработал GitHub Action. Вам нужно получить адрес образа <https://github.com/><github_username>/architecture-sprint-3/pkgs/container/architecture-sprint-3

Он выглядит таким образом
```ghcr.io/<github_username>/architecture-sprint-3:latest```

Замените адрес образа в файле `helm/smart-home-monolith/values.yaml` на полученный файл:

```yaml
image:
  repository: ghcr.io/<github_username>/architecture-sprint-3
  tag: latest
```

## Настройка terraform

[Установите Terraform](https://yandex.cloud/ru/docs/tutorials/infrastructure-management/terraform-quickstart#install-terraform)

Создайте файл ~/.terraformrc

```hcl
provider_installation {
  network_mirror {
    url = "https://terraform-mirror.yandexcloud.net/"
    include = ["registry.terraform.io/*/*"]
  }
  direct {
    exclude = ["registry.terraform.io/*/*"]
  }
}
```

## Применяем terraform конфигурацию

```bash
cd terraform
terraform init
terraform apply
```

## Настройка API GW

```bash
kusk deploy -i api.yaml
```

## Проверяем работоспособность

```bash
kubectl port-forward svc/kusk-gateway-envoy-fleet -n kusk-system 8080:80
curl localhost:8080/hello
```

## Delete minikube

```bash
minikube delete
```
